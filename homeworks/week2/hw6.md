``` js
function isValid(arr) {
  for(var i=0; i<arr.length; i++) {
    if (arr[i] <= 0) return 'invalid'
  }
  for(var i=2; i<arr.length; i++) {
    if (arr[i] !== arr[i-1] + arr[i-2]) return 'invalid'
  }
  return 'valid'
}

isValid([3, 5, 8, 13, 22, 35])
```

## 執行流程
1. 第十一行，執行 isValid 函式，並給定參數 [3, 5, 8, 13, 22, 35] 。
2. 執行迴圈。設定變數 i 為 0，檢查變數 0 是否小於 6。是，進入迴圈。
3. 執行判斷式，3 小於等於 0 不成立，第一次迴圈結束。
4. 回到迴圈，變數 i + 1。檢查 1 是否小於 6。是，進入迴圈。
5. 執行判斷式，5 小於等於 0 不成立，第二次迴圈結束。
6. 回到迴圈，變數 i + 1。檢查 2 是否小於 6。是，進入迴圈。
7. 執行判斷式，8 小於等於 0 不成立，第三次迴圈結束。
8. 回到迴圈，變數 i + 1。檢查 3 是否小於 6。是，進入迴圈。
9. 執行判斷式，13 小於等於 0 不成立，第四次迴圈結束。
10. 回到迴圈，變數 i + 1。檢查 4 是否小於 6。是，進入迴圈。
11. 執行判斷式，22 小於等於 0 不成立，第五次迴圈結束。
12. 回到迴圈，變數 i + 1。檢查 5 是否小於 6。是，進入迴圈。
13. 執行判斷式，35 小於等於 0 不成立，第六次迴圈結束。
14. 回到迴圈，變數 i + 1。檢查 6 是否小於 6。否，終止迴圈，跳至第五行。
15. 執行迴圈。設定變數 i 為 2，檢查變數 2 是否小於 6。是，進入迴圈。
16. 執行判斷式，8 不等於 5 + 3 不成立，第一次迴圈結束。
17. 執行迴圈，變數 i + 1。檢查變數 3 是否小於 6。是，進入迴圈。
18. 執行判斷式，13 不等於 8 + 5 不成立，第二次迴圈結束。
19. 執行迴圈，變數 i + 1。檢查變數 4 是否小於 6。是，進入迴圈。
20. 執行判斷式，22 不等於 13 + 8 不成立，第三次迴圈結束。
21. 執行迴圈，變數 i + 1。檢查變數 5 是否小於 6。是，進入迴圈。
22. 執行判斷式，35 不等於 22 + 13 不成立，第四次迴圈結束。
23. 執行迴圈，變數 i + 1。檢查變數 6 是否小於 6。否，終止迴圈，跳至第八行。
24. 回傳字串 valid。
25. isValid 函式結束。

## 函式標準化流程
1. 第一行，執行 isValid 函式，並給定參數陣列 arr。
2. 第二行，執行迴圈。設定變數 i 為 0，檢查變數 i 是否小於參數陣列 arr 的長度，如果是，就進入迴圈。
3. 第三行，執行判斷式，如果陣列 arr 的第 i 個數字小於等於 0，則回傳字串 invalid。
4. 迴圈結束，回到第二行，變數 i + 1。檢查 i 是否小於陣列 arr 的長度，如果是，進入迴圈（回到步驟 3）；如果否，終止迴圈，跳至第五行（步驟 5）。
5. 第五行，執行迴圈。設定變數 i 為 2，檢查變數 i 是否小於參數陣列 arr 的長度，如果是，就進入迴圈。
6. 第六行，執行判斷式，如果陣列 arr 的第 i 個數字不等於陣列 arr 的第 i - 1 個數字加上陣列 arr 的第 i - 2 個數字，則回傳字串 invalid。
7. 迴圈結束，回到第五行，變數 i + 1。檢查 i 是否小於陣列 arr 的長度，如果是，進入迴圈（回到步驟 6）；如果否，終止迴圈，跳至第八行（步驟 8）。
8. 回傳字串 valid。
9. isValid 函式結束。

## 一些觀察
1. 這個函式檢查了兩個條件，第一是陣列裡的數字必須都是正數，第二是陣列中任一數必然等於其前兩個數字相加的總和。若無法同時滿足這兩個條件就會得到 invalid。

2. 但似乎條件並沒有太嚴謹，例如今天我使用小於三個數字的陣列測試，一樣也會得到 valid。所以或許函式要再加上一個檢查陣列裡的數字是否大於三個的判斷。